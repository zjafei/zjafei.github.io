---
title: 从高阶函数到高阶组件
date: 2017-11-15 09:33:02
tags: ['前端','js','javascript','react','高阶函数','纯函数','高阶组件']
category: 'coding'
---
## 纯函数([https://zh.wikipedia.org/wiki/纯函数](https://zh.wikipedia.org/wiki/%E7%BA%AF%E5%87%BD%E6%95%B0))
如果一个函数遵循以下几个规则那么他就是纯函数：
+ 函数处理的数据都是通过参数传递给函数。
+ 他不接受不确定的数据或者任何其他数据（他们通常是[副作用](https://zh.wikipedia.org/wiki/函数副作用)的）。
+ 同样的输入，函数将得到同样的输出。

纯函数的好处主要有几点：
+ 无状态。线程安全。不需要线程同步。
+ `纯函数相互调用组装起来的函数，还是纯函数`。
+ 应用程序或者运行环境（Runtime）可以对纯函数的运算结果进行缓存，运算加快速度。<!--more-->

例子：
```javascript
//纯函数
function add(x, y) {
    return x + y;
}
```
```javascript
//不是纯函数
var y = 2;

function badAdd(x) {
    return x + y;
} 
```

## 高阶函数([https://zh.wikipedia.org/wiki/高阶函数](https://zh.wikipedia.org/wiki/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0))
在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数：
+ 接受一个或多个函数作为输入
+ 输出一个函数

例子：
```javascript
function addition(x, y) {
    return X + Y;
}
```
业务发生改变需要console，add不能修改，因为你不知道add都用在了哪里，你的修改会对现有代码参数什么样的后果。于是有了下面的结果：
```javascript
function additionAndLog(x, y) {
    var result = addition(x, y);
    console.log('Result', result);
    return result;
}
```
由于你的修改没有对现有代码产生不好的影响，所以减法、乘法、除法都要做console的添加：
```javascript
function subtractionAndLog(x, y) {
    var result = subtraction(x, y);
    console.log('Result', result);
    return result;
}
```
```javascript
function multiplicationAndLog(x, y) {
    var result = multiplication(x, y);
    console.log('Result', result);
    return result;
}
```
```javascript
function divisionAndLog(x, y) {
    var result = division(x, y);
    console.log('Result', result);
    return result;
}
```
由于你的修改没有对现有代码产生不好的影响，所以n个函数都要做console的添加！！！
改变思路：

```javascript
function logAndReturn(func) {
    return function() {
        var args = Array.prototype.slice.call(arguments)
        //arguments是个类数组 {0:42, 1:52, 2:63, length:3}
        //Array的实例的slice给arguments使用
        var result = func.apply(null, args);
        /**
        Function.apply(obj,args)能接受两个参数：
        obj: 这个对象将代替Function类中的this对象
        args： 这是个数组，它将作为参数传递给Function类
        function Person(name,age){
            this.name=name;
            this.age=age;
            this.sayhello=function(){alert("hello")};
        } 
        function Student(name,age,grade,school){
            Person.apply(this,arguments);
            this.grade=grade;
            this.school=school;
        } 
        */
        console.log('Result', result);
        return result;
    }
}

const additionAndLog =  logAndReturn(addition);
const multiplicationAndLog =  logAndReturn(subtraction);
const multiplicationAndLog =  logAndReturn(multiplication);
const divisionAndLog =  logAndReturn(division);
```
## 高阶组件
一个路由组件的例子：
```html
<Link to="/" activeClassName="active-link"> Home </Link>
<Link to="/about" activeClassName="active-link"> About</Link>
<Link to="/contact" activeClassName="active-link"> Contact</Link>
```
初步优化，提取相同的代码：
```javascript
var AppLink=React.createClass({
    render:function(){
        return(
            <Link to={this.props.to} activeClassName="active-link">
                {this.props.children}
            </Link>;
        );
    }
});
```
改变现在的路由组件：
```html
<AppLink to="/">Home</AppLink>
<AppLink to="/about">About</AppLink>
<AppLink to="/contact">Contact</AppLink>
```
进一步优化，对props的覆盖控制：
```javascript
//高阶组件覆盖，强调统一
var AppLink=React.createClass({
    render:function(){
        const {children, props} = this.props;
        return(
            <Link {...props} activeClassName="active-link">
                {children}
            </Link>;
        );
    }
});

//调用组件覆盖，强调默认值和定制化
var AppLink=React.createClass({
    render:function(){
        const {children, props} = this.props;
        return(
            <Link activeClassName="active-link" {...props}>
                {children}
            </Link>;
        );
    }
});
```
## SAAS项目的应用实例-----<AuthControl>权限控制组件

```Javascript
class AuthControl extends React.Component {
    render() {
        const { roles, userRoles, deniedAuth, children } = this.props;

        if (_.intersection(roles, userRoles).length === 0) {
            if (deniedAuth !== undefined) {
                return deniedAuth;
            }
            return null;
        } else {
            return (children);
        }
    }
}

AuthControl.propTypes = {
    roles: React.PropTypes.array.isRequired,
    userRoles: React.PropTypes.array.isRequired,
    children: React.PropTypes.element,
    deniedAuth: React.PropTypes.element,
};

<AuthControl
    roles={['admin']} 
    userRoles={[‘user’]}
    deniedAuth={<div>没有权限</div>}
>
    <div>有权限</div>
</AuthControl>
```
## 结论
通过将纯函数和高阶函数的函数式编程的原理应用到React，您可以创建一个更容易维护和使用的代码库。